# pnpm 25H1 핵심 변경사항

## 서론 (Introduction)

**pnpm**은 Node.js 생태계에서 빠르고 디스크 공간 효율적인 패키지 관리자로 자리매김하며, 특히 **모노레포(monorepo)** 환경에서 뛰어난 성능과 엄격한 의존성 관리로 주목받고 있습니다. 2025년 상반기(1월\~6월)는 pnpm에게 있어 중요한 변화의 시기였습니다. 이 기간 동안 pnpm은 주요 버전 업데이트인 **v10**을 출시하며 보안, 성능, 효율성 측면에서 상당한 개선을 이루었으며, 동시에 개발자의 코딩 구현 방식과 워크플로우에 직접적인 영향을 미치는 여러 \*\*파괴적 변경사항(breaking changes)\*\*을 도입했습니다. 또한, pnpm 9.5 버전에서는 모노레포 의존성 관리를 혁신할 **'카탈로그(Catalogs)'** 기능이 도입되어, 대규모 프로젝트의 유지보수성을 크게 향상시킬 잠재력을 보여주었습니다. 본 보고서는 2025년 상반기 pnpm의 핵심 변경사항들을 심층적으로 분석하고, 특히 개발자들이 코드를 구현하고 프로젝트를 관리하는 방식에 미치는 영향을 중심으로 상세한 내용을 제공하고자 합니다.

-----

## 1\. pnpm v10 핵심 변경사항 (pnpm v10 Core Changes)

pnpm v10은 2025년 1월 15일에 출시되었으며, **보안 강화**, **성능 최적화**, 그리고 **내부 구조의 효율성 증대**에 중점을 두었습니다. 이 버전은 여러 파괴적 변경사항을 포함하고 있어, 기존 pnpm 사용자들은 업그레이드 시 주의 깊은 검토와 코드베이스 및 설정 파일 업데이트가 필요합니다.

### 1.1. 출시 배경 및 목표 (Release Background and Goals)

pnpm v10의 출시는 패키지 관리의 보안 취약점을 줄이고, 설치 및 빌드 프로세스의 효율성을 극대화하며, 대규모 프로젝트 환경에서의 안정성을 높이는 데 목표를 두었습니다. 특히, 소프트웨어 공급망 공격(supply chain attacks)의 위협이 증가함에 따라, **기본적으로 안전한(secure-by-default)** 환경을 제공하려는 노력이 두드러집니다. 이는 패키지 관리자가 단순히 패키지를 설치하는 것을 넘어, 설치 과정 자체의 보안을 보장하는 핵심적인 역할을 수행해야 한다는 인식의 변화를 반영합니다.

### 1.2. 주요 Breaking Changes 및 코딩 구현 영향 (Major Breaking Changes and Coding Implementation Impact)

pnpm v10에서 도입된 주요 파괴적 변경사항들은 개발자의 의존성 관리 방식, 스크립트 실행 환경, 그리고 `node_modules` 구조에 직접적인 영향을 미칩니다. 이러한 변화는 단순히 기능 추가를 넘어, pnpm의 핵심 철학인 엄격성, 효율성, 보안을 더욱 강화하는 방향으로 진화하고 있음을 보여줍니다.

#### 의존성 라이프사이클 스크립트 실행 기본 비활성화 (Dependency lifecycle scripts execution disabled by default)

* **설명**: 보안 강화를 위해, 이제 의존성 패키지의 라이프사이클 스크립트(예: `preinstall`, `postinstall`)는 기본적으로 설치 중에 실행되지 않습니다. 특정 의존성에 대해 스크립트 실행을 허용하려면, `package.json` 파일의 `pnpm.onlyBuiltDependencies` 필드에 해당 의존성을 명시적으로 나열해야 합니다.

* **코딩 구현 영향**: 이 변경은 개발자가 의도치 않은 악성 스크립트 실행으로부터 더욱 안전해지도록 돕습니다. 이는 패키지 관리 시스템의 공급망 보안을 근본적으로 개선하는 중요한 변화입니다. 그러나 빌드 프로세스나 특정 기능(예: 네이티브 모듈 컴파일)을 위해 라이프사이클 스크립트 실행이 필수적인 의존성이 있는 경우, 개발자는 해당 의존성을 `pnpm.onlyBuiltDependencies`에 수동으로 추가해야 합니다. 이를 누락할 경우, 해당 의존성이 올바르게 설치 또는 빌드되지 않아 런타임 오류나 기능 불능을 초래할 수 있습니다.

* **심층 분석**: 이 변화는 패키지 관리의 보안 모델에 있어 중요한 패러다임 전환을 나타냅니다. 기존의 암묵적인 "모두 신뢰" 모델에서 명시적인 "**필요한 것만 신뢰**" 모델로 이동한 것입니다. 이는 최근 증가하는 공급망 공격(예: 악성 패키지가 `postinstall` 스크립트를 통해 유해한 코드를 주입하는 경우)에 대한 대응으로, pnpm이 "**기본 보안**" 자세를 채택했음을 의미합니다. 이러한 변화는 보안에 이점을 제공하지만, 개발자에게는 모든 합법적인 의존성 중 스크립트 실행이 필요한 것을 식별하고 구성해야 하는 부담을 줍니다. 이는 기존 `package.json` 파일과 `node_modules` 구조에 대한 철저한 감사를 요구하며, 특히 전이적 의존성이 많은 프로젝트에서 더욱 중요합니다. 결과적으로 개발자는 의존성 선택에 대해 더욱 의도적이고 보안에 민감하게 접근해야 하며, 이는 "설정하고 잊어버리는" 패키지 설치 방식에서 벗어나게 합니다. 자동화된 CI/CD 파이프라인도 `onlyBuiltDependencies`가 올바르게 구성되지 않으면 중단될 수 있으므로, CI/CD 스크립트 조정이 필요합니다.

#### `pnpm link` 명령 동작 업데이트 (`pnpm link` behavior updated)

* **설명**: `pnpm link` 명령이 이제 루트 `package.json`에 `overrides`를 추가합니다. 워크스페이스 내에서는 이 override가 워크스페이스 루트에 추가되어 해당 의존성이 워크스페이스의 모든 프로젝트에 연결됩니다. 전역 링크(global linking)의 경우, 이제 패키지 디렉토리에서 `pnpm link`만 실행하면 됩니다 (이전에는 `pnpm link -g`가 필요했습니다).

* **코딩 구현 영향**: 이 변화는 워크스페이스 내에서 로컬 의존성을 관리하는 방식을 더욱 중앙집중화하고 명시적으로 만듭니다. 이는 대규모 모노레포에서 의존성 충돌을 줄이는 데 도움이 될 수 있습니다. 그러나 `pnpm link` 실행 시 루트 `package.json`이 자동으로 수정되므로, 개발자는 이러한 자동 변경을 인지하고 버전 관리 시스템에서 적절히 관리해야 합니다. 전역으로 패키지를 링크하는 과정은 간소화되어, 로컬 개발 환경에서 특정 패키지를 테스트하거나 디버깅할 때 편리합니다.

* **심층 분석**: `pnpm link`가 이제 `overrides`를 루트 `package.json`에 추가하여 워크스페이스의 모든 프로젝트에 영향을 미치도록 한 것은 중요한 변화입니다. `package.json`의 `overrides` 필드는 일반적으로 전이적 의존성이 다른 버전을 요구하더라도 특정 의존성의 특정 버전을 강제하는 데 사용됩니다. `overrides`를 링크에 사용함으로써, pnpm은 이 링크된 의존성이 우선권을 가지도록 명시적으로 선언하며, 이는 워크스페이스 전반의 일관성을 보장하는 강력한 메커니즘입니다. 이러한 변화의 원인은 복잡한 모노레포 내에서 보다 강력하고 명시적인 로컬 의존성 관리의 필요성에서 비롯되었을 가능성이 높습니다. 그 결과, 로컬 링크에 대한 보다 중앙 집중적이고 강력한 접근 방식이 채택되었습니다. 이는 모노레포 사용자에게 상당한 영향을 미칩니다. 일관성을 목표로 하지만, 한 하위 프로젝트에서의 `pnpm link` 작업이 이제 루트 `package.json`을 통해 워크스페이스의 모든 다른 프로젝트에 영향을 미칠 수 있음을 의미합니다. 팀 환경에서는 의도치 않은 부작용이나 루트 `package.json`에서의 병합 충돌을 피하기 위해 신중한 조정이 필요합니다. 개발자는 로컬 링크가 이제 더 넓은 범위의 영향을 미친다는 것을 이해해야 합니다. 루트 `package.json`의 자동 수정은 이 파일이 더 자주 업데이트될 것이므로, 팀은 워크플로우에 따라 이러한 변경 사항을 커밋하거나 무시하는 명확한 지침을 수립해야 합니다.

#### SHA256을 통한 보안 해싱 강화 (Secure hashing with SHA256)

* **설명**: 여러 해싱 알고리즘이 SHA256으로 업데이트되어 보안 및 일관성이 강화되었습니다.

* **코딩 구현 영향**: 이 변경사항은 대부분의 개발자에게는 투명하게 적용되지만, 패키지 무결성 검증의 기반이 되는 해싱 알고리즘이 더욱 강력해졌다는 것을 의미합니다. 이는 패키지 변조 공격에 대한 방어력을 높여줍니다. `pnpm-lock.yaml` 파일에 기록되는 해시 값이 더욱 안전해져, 의존성 설치의 신뢰성과 재현성이 향상됩니다.

* **심층 분석**: SHA256으로의 해싱 알고리즘 업데이트는 pnpm이 현대적인 보안 표준을 준수하려는 노력을 보여줍니다. SHA1과 같은 이전 해싱 알고리즘은 이론적인 충돌 취약점이 알려져 있으며, 실제 공격은 어렵지만 SHA256으로의 전환은 선제적인 조치입니다. 이는 소프트웨어 공급망의 위협 환경이 진화하고 더 강력한 암호화 기본 요소가 필요하다는 점을 반영합니다. 결과적으로 다운로드된 패키지에 대한 무결성 검증이 강화되어, 악의적인 행위자가 탐지 없이 패키지를 변조하기가 더 어려워집니다. 개발자는 암묵적으로 패키지 관리자가 변조되지 않은 코드를 제공할 것이라고 신뢰합니다. 이 업데이트는 그 신뢰를 강화하여, 손상된 의존성으로 인한 잠재적인 위험을 줄입니다. 엄격한 보안 규정 준수 요구 사항이 있는 조직의 경우, 이 업데이트는 현대 암호화 표준을 충족하는 데 도움이 됩니다. 직접적인 코드 변경은 필요 없지만, 프로젝트의 전반적인 보안 태세에 기여하는 근본적인 개선 사항입니다.

#### 설정 업데이트 (Configuration updates)

* **`manage-package-manager-versions` 기본 활성화**: pnpm이 이제 `package.json`의 `packageManager` 필드를 기반으로 자체 버전을 관리합니다.

  * **코딩 구현 영향**: 팀 내 pnpm 버전 일관성을 강제하여, "내 컴퓨터에서는 되는데 네 컴퓨터에서는 안 돼"와 같은 문제를 줄여줍니다. 특히 모노레포에서 여러 프로젝트가 동일한 pnpm 버전을 사용하도록 보장하여 빌드 환경의 예측 가능성을 높입니다.

* **`public-hoist-pattern` 기본 비활성화 (Nothing is hoisted by default)**: eslint나 prettier와 같은 패키지도 더 이상 `node_modules`의 루트로 호이스팅되지 않습니다.

  * **코딩 구현 영향**: 이 변화는 pnpm의 핵심 철학인 **엄격한 의존성 관리**를 더욱 강화합니다. 이는 "**유령 의존성(phantom dependencies)**" 문제를 해결하는 데 기여합니다. 즉, `package.json`에 명시되지 않았지만 호이스팅 덕분에 사용 가능했던 패키지들이 이제는 접근 불가능해질 수 있습니다. 기존 프로젝트에서 암묵적으로 호이스팅에 의존했던 경우(예: 직접 설치하지 않은 린터나 포맷터 사용), 이제는 해당 패키지를 `package.json`에 명시적으로 `devDependencies`로 추가해야 합니다. 이를 통해 의존성 그래프가 더욱 명확해지고, 프로젝트의 이식성이 향상됩니다.

* **`virtual-store-dir-max-length` Windows 기본값 감소**: Windows 환경에서의 기본값이 60자로 줄었습니다.

  * **코딩 구현 영향**: Windows OS의 고질적인 긴 경로(path) 문제로 인한 설치 오류를 줄여줍니다. Windows 개발 환경의 안정성이 향상됩니다.

* **심층 분석**: 이 세 가지 설정 변경 사항은 pnpm이 핵심 철학인 엄격성을 강화하면서도 실제적인 사용성을 개선하려는 균형점을 찾고 있음을 보여줍니다. `manage-package-manager-versions`의 기본 활성화와 `public-hoist-pattern`의 기본 비활성화는 빌드의 신뢰성과 예측 가능성을 높이는 데 중점을 둡니다. 이는 암묵적인 의존성을 제거하고 일관된 도구 사용을 보장함으로써, 특히 복잡한 모노레포에서 "내 컴퓨터에서는 되는데"와 같은 문제를 줄이는 데 기여합니다. 결과적으로 개발자에게는 초기 구성 작업이 늘어날 수 있지만, 장기적으로는 더 명확한 의존성 그래프와 적은 환경 관련 문제로 이어집니다. 반면, `virtual-store-dir-max-length`의 Windows 기본값 감소는 Windows 운영 체제의 오랜 경로 길이 제한으로 인한 빌드 실패 문제를 해결합니다. 이는 Windows 사용자에게 더 견고한 경험을 제공하여 일반적인 불만 사항을 줄입니다. 개발자는 이러한 새로운 기본값을 반영하여 `package.json` 및 `pnpm-workspace.yaml`을 사전에 검토해야 합니다. `public-hoist-pattern` 변경은 모노레포에서 명시적인 의존성 선언의 필요성을 특히 강조하며, 대규모 프로젝트 유지보수를 위한 모범 사례와 일치합니다. 이는 기존 프로젝트에 대한 "의존성 정리" 단계를 필요로 할 수 있습니다.

#### 스크립트 환경 변수 감소 (Reduced script environment variables)

* **설명**: 스크립트 실행 중 설정되는 `npm_package_*` 환경 변수의 수가 줄어들었으며, `name`, `version`, `bin`, `engines`, `config`만 유지됩니다.

* **코딩 구현 영향**: 기존에 제거된 `npm_package_*` 변수(예: `npm_package_description`, `npm_package_main` 등)에 의존하는 커스텀 스크립트나 빌드 도구는 더 이상 올바르게 작동하지 않을 수 있습니다. 개발자는 이러한 스크립트를 검토하고 필요한 정보를 다른 방식으로(예: `package.json` 직접 파싱) 얻도록 수정해야 합니다. 스크립트 실행 환경이 더 간소화되어, 불필요한 정보 노출을 줄이고 잠재적인 보안 위험을 낮춥니다.

* **심층 분석**: 환경 변수의 감소는 스크립트 실행 환경에 대한 pnpm의 제어를 강화하려는 의도를 보여줍니다. 이는 성능(설정할 변수가 적음), 보안(정보 유출 감소), 또는 패키지 메타데이터에 액세스하는 보다 표준화된 방법을 강제하기 위한 것일 수 있습니다. 이러한 변화의 원인은 보안 문제(공격 표면 감소)와 더 깔끔하고 예측 가능한 스크립트 실행 환경에 대한 요구 사항의 조합일 가능성이 높습니다. 그 결과, 제거된 변수에 의존하는 스크립트는 중단될 것이므로 업데이트가 필요합니다. 개발자는 패키지 메타데이터와 상호 작용하는 모든 사용자 정의 스크립트(예: `package.json` 스크립트, CI/CD 스크립트)가 더 이상 사용되지 않는 환경 변수에 의존하지 않는지 확인하기 위해 감사해야 합니다. 이는 견고하고 자체 포함된 스크립트의 필요성을 강조합니다. 또한, 환경 변수에 의존하는 것보다 Node.js의 `require()` 또는 `fs` 모듈을 통해 `package.json` 데이터에 직접 액세스하는 것이 더 안정적이고 디버깅하기 쉽다는 모범 사례를 장려합니다.

#### `NODE_ENV=production` 환경에서도 모든 의존성 설치 (All dependencies are installed even if `NODE_ENV=production`)

* **설명**: 이제 `NODE_ENV=production`으로 설정되어 있어도 모든 의존성(개발 의존성 포함)이 설치됩니다.

* **코딩 구현 영향**: 개발 환경과 프로덕션 빌드 환경 간의 의존성 설치 동작이 일관됩니다. 이는 프로덕션 빌드에서 누락된 의존성으로 인한 런타임 오류를 방지하는 데 도움이 될 수 있습니다. 그러나 프로덕션 환경에 배포할 때 개발 의존성까지 포함되어 설치되므로, 불필요한 디스크 공간 사용 및 설치 시간 증가가 발생할 수 있습니다. 개발자는 이 변경사항을 고려하여 빌드 및 배포 전략을 조정해야 합니다 (예: `npm prune --production` 또는 `pnpm deploy`와 같은 명령으로 불필요한 의존성 제거).

* **심층 분석**: 전통적으로 `NODE_ENV=production`은 `devDependencies`를 건너뛰었습니다. 이 변화는 일부 프로젝트에서 `devDependencies`로만 나열되었지만 실제로는 프로덕션 빌드에 필수적인 피어 의존성 또는 기타 빌드 시간 의존성이 누락되어 문제가 발생했을 수 있음을 시사합니다. 이는 초기 설치 단계에서 최소한의 공간을 차지하는 것보다 빌드의 재현성과 정확성을 우선시하는 것입니다. 이 변화의 원인은 `devDependencies`가 건너뛰어져 불완전하거나 부정확한 프로덕션 빌드로 이어지고 런타임 오류를 유발하는 문제일 가능성이 높습니다. 그 결과, 초기 설치는 더 견고해지지만, 불필요한 의존성을 "정리"하는 책임은 배포 파이프라인의 후기 단계로 넘어갑니다. 이 변화는 배포 파이프라인의 재평가를 필요로 합니다. 프로덕션 아티팩트 크기를 최소화하는 것이 중요하다면, 팀은 `devDependencies`를 제거하는 단계를 명시적으로 추가해야 합니다(예: `inject-workspace-packages=true`와 함께 `pnpm deploy`를 사용하거나 전용 정리 단계 사용). 이는 일관성 증가와 "누락된 의존성" 오류 감소라는 이점을 제공하지만, 관리되지 않으면 프로덕션 환경에서 잠재적으로 더 큰 초기 설치 크기와 더 긴 설치 시간이라는 대가를 치릅니다. 개발자는 이러한 트레이드오프를 인지하고 그에 따라 최적화해야 합니다.

#### 글로벌 스토어 변경 및 사이드 이펙트 인덱스 효율화 (Global store changes & More efficient side-effects index)

* **설명**: 스토어 버전이 v10으로 업데이트되었으며, 인덱스 파일이 콘텐츠 해시 및 패키지 식별자를 사용하여 저장됩니다. 사이드 이펙트(side effects)는 이제 모든 파일 대신 파일 차이점만 나열하여 더욱 효율적으로 추적됩니다.

* **코딩 구현 영향**: 이 변경사항들은 주로 pnpm의 내부 저장소 구조 및 효율성에 관한 것이므로, 대부분의 개발자에게는 투명하게 작동합니다. 결과적으로 **디스크 공간 절약 및 패키지 설치 속도 향상**이라는 이점을 제공하여 개발 워크플로우의 전반적인 성능을 개선합니다.

* **심층 분석**: 콘텐츠 해시를 사용하고 사이드 이펙트에 대한 파일 차이점만 추적하는 것은 pnpm의 핵심 가치 제안인 **디스크 공간 효율성**과 **속도**를 직접적으로 다룹니다. 패키지와 그 사이드 이펙트(예: 컴파일된 바이너리)가 저장되고 링크되는 방식을 최적화함으로써, pnpm은 중복 데이터를 더욱 줄이고 후속 설치 속도를 높일 수 있습니다. 이러한 변화의 원인은 pnpm의 핵심 차별화 요소(속도, 효율성)를 지속적으로 추구하는 것입니다. 그 결과는 최종 사용자에게 더 빠르고 안정적인 설치로 이어지는 최적화된 기본 저장 메커니즘입니다. 직접적인 코드 변경은 필요 없지만, 이러한 개선 사항은 특히 대규모 프로젝트나 빈번한 의존성 업데이트에 있어 더 원활하고 빠른 개발 경험에 기여합니다. 이는 대기 시간을 줄이고 전반적인 생산성을 향상시킵니다. 또한, 더 효율적이고 견고한 내부 저장소는 세분화된 콘텐츠 주소 지정 및 사이드 이펙트 관리에 의존할 수 있는 미래 pnpm 기능의 토대를 마련합니다.

### 1.3. 기타 Breaking Changes (Other Breaking Changes)

pnpm v10에는 위에서 언급된 주요 변경사항 외에도 개발 워크플로우에 영향을 미칠 수 있는 몇 가지 추가적인 파괴적 변경사항이 포함되어 있습니다.

* **\# 문자 이스케이프 (Escaping `#` Character in `node_modules/.pnpm` Directory Names)**: `node_modules/.pnpm` 내 디렉토리 이름에서 `#` 문자가 이제 이스케이프됩니다.

  * **코딩 구현 영향**: 파일 시스템 경로를 직접 다루는 스크립트나 도구가 있다면, 이 변경사항을 고려하여 경로 처리 로직을 업데이트해야 할 수 있습니다.

* **`pnpm add --global pnpm / @pnpm/exe` 명령 사용 불가 (Disabling `pnpm add --global` for self-update)**: `pnpm add --global pnpm` 또는 `pnpm add --global @pnpm/exe` 실행 시 오류가 발생하며, 대신 `pnpm self-update`를 사용하도록 안내합니다.

  * **코딩 구현 영향**: pnpm 자체를 업데이트하는 스크립트(예: CI/CD 설정)가 있다면, `pnpm self-update` 명령으로 변경해야 합니다. 이는 pnpm 버전 관리의 일관성과 안정성을 높이는 조치입니다.

* **URL 기반 의존성 잠금 파일 기록 방식 변경 (URL-based Dependency Lockfile Recording Changes)**: URL을 통해 추가된 의존성은 이제 잠금 파일에 최종적으로 확인된 URL을 기록하여, 모든 리디렉션이 완전히 캡처되도록 합니다.

  * **코딩 구현 영향**: 특정 URL(예: GitHub 릴리스)을 통해 직접 의존성을 참조하는 프로젝트의 경우, `pnpm-lock.yaml` 파일의 내용이 변경될 수 있습니다. 이는 잠금 파일의 재현성을 높이는 긍정적인 변화입니다.

* **`pnpm deploy` 명령 동작 제약 (Constraints on `pnpm deploy` Command)**: `pnpm deploy` 명령은 이제 `inject-workspace-packages=true`로 설정된 워크스페이스에서만 작동합니다.

  * **코딩 구현 영향**: `pnpm deploy`를 사용하여 프로젝트를 배포하는 경우, 워크스페이스 설정(`pnpm-workspace.yaml`)에 `inject-workspace-packages: true`가 명시되어 있는지 확인해야 합니다. 이 설정은 로컬 워크스페이스 의존성을 심링크 대신 하드링크로 연결하는 기능을 제어합니다.

* **Lockfile v6 to v9 변환 기능 제거 (Removal of Lockfile v6 to v9 Conversion)**: 이전 버전의 잠금 파일(v6)을 v9으로 변환하는 기능이 제거되었습니다.

  * **코딩 구현 영향**: 매우 오래된 `pnpm-lock.yaml` 파일을 사용하는 프로젝트의 경우, v10으로 업그레이드하기 전에 수동으로 잠금 파일을 다시 생성하거나, 지원되는 중간 버전에서 한 번 변환 과정을 거쳐야 할 수 있습니다.

* **`pnpm test` 인자 전달 방식 변경 (Changes in `pnpm test` Argument Passing)**: `pnpm test` 명령은 이제 `test` 키워드 뒤의 모든 인자를 기본 스크립트에 직접 전달합니다.

  * **코딩 구현 영향**: 테스트 스크립트에 인자를 전달하는 방식이 더욱 직관적으로 변합니다. 기존에 `pnpm test -- --arg`와 같이 `--`를 사용하여 인자를 분리했던 경우, 이제는 `--` 없이 `pnpm test --arg`로 직접 전달할 수 있습니다.

### 1.4. 주요 Minor Changes (Key Minor Changes)

pnpm v10은 여러 파괴적 변경사항 외에도 개발 경험을 개선하고 새로운 기능을 도입하는 몇 가지 중요한 마이너 변경사항을 포함합니다.

#### "Configuration Dependencies" 지원 추가 (Added Support for "Configuration Dependencies")

* **설명**: 새로운 유형의 의존성인 "**Configuration Dependencies**"가 추가되었습니다. 이 의존성들은 다른 모든 유형의 의존성(`dependencies`, `devDependencies`, `optionalDependencies`)보다 먼저 설치됩니다. 설정 의존성은 자체 의존성이나 라이프사이클 스크립트를 가질 수 없습니다.

* **코딩 구현 영향**: 이 기능은 프로젝트 빌드 환경을 설정하는 데 필요한 도구나 스크립트(예: 코드 생성기, 환경 설정 스크립트)를 주 의존성 설치 전에 미리 준비할 수 있게 하여 빌드 프로세스의 안정성과 예측 가능성을 높입니다. 특히 모노레포에서 공통 빌드 도구나 설정 패키지를 관리할 때 유용하며, 각 프로젝트가 올바른 빌드 환경에서 시작하도록 보장할 수 있습니다.

* **심층 분석**: "Configuration Dependencies"의 도입은 빌드 프로세스에 대한 보다 세분화된 제어를 가능하게 합니다. 이러한 의존성이 다른 모든 의존성보다 먼저 설치된다는 점은 빌드 프로세스의 기초적인 요소임을 시사합니다. 자체 의존성이나 라이프사이클 스크립트를 가질 수 없다는 제약은 이들이 단순하고 자체 포함된 설정 도구로 사용되어, 초기 단계에서 복잡한 의존성 체인을 방지하려는 의도를 보여줍니다. 이는 빌드 프로세스의 조정에 관한 것입니다. 이러한 변화의 원인은 복잡한 프로젝트에서 특정 도구나 구성이 주 의존성이 해결되기 전에 존재해야 하는 경우와 같이, 빌드 환경 설정에 대한 더 세분화된 제어의 필요성입니다. 그 결과는 빌드 도구와의 "닭이 먼저냐 달걀이 먼저냐" 문제를 줄여주는, 더 견고하고 예측 가능한 빌드 프로세스입니다. 개발자는 이제 구성 관련 의존성을 런타임 의존성과 명시적으로 분리하여 빌드 파이프라인을 개선할 수 있습니다. 이는 더 깔끔한 `package.json` 파일과 더 논리적인 빌드 단계로 이어집니다. 또한, 기초적인 도구가 먼저 준비되도록 보장함으로써, 경쟁 조건이나 부적절한 도구 설정으로 인한 CI/CD 파이프라인의 불안정성을 줄일 수 있습니다.

#### 새로운 설정 옵션 (`verify-deps-before-run`, `inject-workspace-packages`) (New Configuration Options)

* **`verify-deps-before-run`**: 스크립트 실행 전에 `node_modules`의 상태를 pnpm이 어떻게 확인할지 제어합니다.

  * **코딩 구현 영향**: 개발자는 이 설정을 통해 스크립트 실행 전 의존성 검사의 엄격도를 조절하여, 개발 속도와 빌드 안정성 사이의 균형을 맞출 수 있습니다.

* **`inject-workspace-packages`**: 모든 로컬 워크스페이스 의존성을 심링크 대신 하드링크로 연결할 수 있도록 합니다.

  * **코딩 구현 영향**: 하드링크는 심링크보다 파일 시스템 수준에서 더 견고할 수 있으며, 일부 빌드 도구와의 호환성을 개선할 수 있습니다. 특히 `dependenciesMeta.injected: true`와 함께 사용될 때, 빌드된 결과물이 가상 스토어에 직접 주입되어 소비 프로젝트에서 즉시 사용 가능하게 합니다.
  * `pnpm --recursive run build`와 같은 명령으로 여러 프로젝트를 빌드할 때, 주입된 패키지가 재빌드된 후 소비 프로젝트가 재빌드되기 전에 업데이트되어야 하는 복잡한 시나리오에 유용합니다.
  * `pnpm-sync`와 같은 서드파티 도구와 함께 사용하면 더욱 효율적입니다.

* **심층 분석**: 이 두 가지 새로운 설정은 pnpm이 모노레포 지원을 지속적으로 개선하고 있음을 보여줍니다. `verify-deps-before-run`은 속도(검사 건너뛰기)와 안정성(`node_modules`가 일관적인지 확인) 사이의 트레이드오프를 해결합니다. `inject-workspace-packages`는 로컬 패키지가 링크되고 업데이트되는 방식과 같은 모노레포 빌드의 복잡성을 직접적으로 다룹니다. 이러한 변화의 원인은 복잡한 모노레포에서 pnpm의 채택이 증가하고 빌드 프로세스 및 로컬 패키지 링크에 대한 더 세분화된 제어가 필요하다는 점입니다. 그 결과는 개발자가 성능과 일관성의 균형을 맞추면서 모노레포 워크플로우를 최적화할 수 있는 유연성이 향상됩니다. `inject-workspace-packages`는 특히 패키지가 소비자를 위해 가상 스토어에 "사전 빌드"되거나 "주입"되어야 하는 시나리오와 같이 더 고급 모노레포 빌드 패턴을 가능하게 합니다. 이는 대규모 엔터프라이즈 모노레포에 매우 중요합니다. 개발자는 `verify-deps-before-run`을 사용하여 `node_modules`가 일관적이라고 알려진 환경에서 중복 검사를 건너뛸 수 있으므로 CI/CD 파이프라인을 미세 조정하여 빌드 속도를 높일 수 있습니다.

#### 더 빠른 반복 설치 (Faster repeat installations)

* **설명**: 반복 설치 시 `node_modules`가 최신 상태인지 빠르게 확인합니다.

* **코딩 구현 영향**: 개발 및 CI/CD 환경에서 `pnpm install`을 다시 실행할 때의 대기 시간이 단축됩니다. 이는 개발자의 생산성을 향상시키는 직접적인 성능 개선입니다.

#### `pnpm add` 및 `pnpm dlx` 동작 개선 (Improvements to `pnpm add` and `pnpm dlx`)

* **`pnpm add`**: 기본 워크스페이스 디렉토리와 통합됩니다.

* **`pnpm dlx`**: 이제 패키지를 정확한 버전으로 확인하고, 이 정확한 버전을 캐시 키로 사용합니다.

* **코딩 구현 영향**: `pnpm add`는 워크스페이스에서 패키지를 추가하는 과정을 더욱 직관적으로 만들고, `pnpm dlx`는 임시 실행 시의 패키지 버전 관리 및 캐싱의 예측 가능성을 높여줍니다.

-----

### Table 1: pnpm v10 주요 Breaking Changes 및 개발자 조치 사항 (Key Breaking Changes in pnpm v10 and Developer Actions)

| 변경사항 (Change)                                | 코딩 구현 영향 (Coding Implementation Impact)                                                                                                              | 개발자 조치 사항 (Developer Action)                                                                                                                                                                                                                                                                                                                 |
| :----------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 의존성 라이프사이클 스크립트 실행 기본 비활성화    | 빌드 스크립트 실행에 필요한 의존성이 올바르게 설치/빌드되지 않을 수 있음.                                                                                   | `package.json`의 `pnpm.onlyBuiltDependencies` 필드에 스크립트 실행이 필요한 의존성을 명시적으로 추가. 기존 프로젝트의 의존성 감사 필요.                                                                                                                                                                                                        |
| `pnpm link` 명령 동작 업데이트 (루트 `package.json`에 `overrides` 추가) | 워크스페이스 내 로컬 링크 시 루트 `package.json`이 자동 수정되어 버전 관리 충돌 가능성 증가.                                                              | `pnpm link` 사용 시 루트 `package.json` 변경 사항 인지 및 관리. 팀 내 워크스페이스 링크 규칙 재정립.                                                                                                                                                                                                                                     |
| `public-hoist-pattern` 기본 비활성화 (호이스팅 없음) | 기존에 암묵적으로 호이스팅에 의존했던 패키지(예: 린터, 포맷터)가 접근 불가해져 빌드/런타임 오류 발생 가능.                                                  | 직접 사용하는 모든 패키지를 `package.json`에 명시적으로 `dependencies` 또는 `devDependencies`로 추가.                                                                                                                                                                                                                                            |
| 스크립트 환경 변수 감소                          | 제거된 `npm_package_*` 변수에 의존하는 커스텀 스크립트(빌드, CI/CD 등)가 오작동할 수 있음.                                                                  | 모든 커스텀 스크립트 검토 및 필요한 패키지 메타데이터를 `package.json` 직접 파싱 등으로 대체.                                                                                                                                                                                                                                               |
| `NODE_ENV=production` 환경에서도 모든 의존성 설치  | 프로덕션 빌드/배포 시 `devDependencies`까지 설치되어 디스크 공간 및 설치 시간 증가 가능.                                                                     | 배포 파이프라인에 `pnpm deploy` (with `inject-workspace-packages=true`) 또는 `npm prune --production`과 같은 명시적인 의존성 정리 단계 추가.                                                                                                                                                                                          |
| `pnpm add --global pnpm / @pnpm/exe` 명령 사용 불가 | pnpm 자체 업데이트 스크립트가 중단될 수 있음.                                                                                                              | pnpm 업데이트 시 `pnpm self-update` 명령으로 변경.                                                                                                                                                                                                                                                                                          |
| `pnpm deploy` 명령 `inject-workspace-packages=true` 제약 | `pnpm deploy` 사용 시 워크스페이스 설정 확인 필요.                                                                                                         | `pnpm-workspace.yaml`에 `inject-workspace-packages: true` 설정이 명시되어 있는지 확인.                                                                                                                                                                                                                                                     |
| `pnpm test` 인자 전달 방식 변경                  | 테스트 스크립트에 인자를 전달하는 방식이 달라져 기존 스크립트 수정 필요.                                                                                     | `pnpm test` 명령 뒤에 인자를 직접 전달하도록 스크립트 업데이트 (예: `--` 제거).                                                                                                                                                                                                                                                          |

-----

## 2\. pnpm 9.5 카탈로그 기능 도입 (Introduction of pnpm 9.5 Catalogs Feature)

2025년 6월에 출시된 pnpm 9.5 버전에서는 **'카탈로그(Catalogs)'** 기능이 도입되어, 모노레포 환경에서의 의존성 관리에 혁신적인 변화를 가져왔습니다. 이 기능은 pnpm의 모노레포 지원을 한층 더 강화하는 전략적인 움직임으로 평가됩니다.

### 2.1. 배경 및 필요성 (Background and Rationale)

대규모 모노레포에서는 수많은 하위 프로젝트가 `react`, `lodash`와 같은 공통 의존성을 공유하는 경우가 많습니다. 이러한 공통 의존성의 버전을 일관되게 유지하는 것은 매우 어려운 과제였습니다. 수동으로 각 `package.json` 파일을 업데이트하거나 `pnpm-lock.yaml` 파일에서 발생하는 잦은 병합 충돌은 개발자의 생산성을 저해하는 주요 원인이었습니다. 카탈로그 기능은 이러한 문제를 해결하고, 워크스페이스 전반에 걸쳐 의존성 버전 일관성을 중앙에서 관리할 수 있는 메커니즘을 제공하기 위해 도입되었습니다.

### 2.2. 카탈로그 정의 및 사용법 (Defining and Using Catalogs)

카탈로그는 `pnpm-workspace.yaml` 파일에 정의되며, `catalog:` 프로토콜을 사용하여 `package.json` 파일에서 참조됩니다. 이를 통해 개발자는 공통 의존성 버전을 한 곳에서 정의하고 여러 프로젝트에서 재사용할 수 있습니다.

#### `pnpm-workspace.yaml`에서의 정의

```yaml
# Default catalog
catalog:
  chalk: ^4.1.2

# Named catalogs
catalogs:
  react16:
    react: ^16.7.0
    react-dom: ^16.7.0
  react17:
    react: ^17.10.0
    react-dom: ^17.10.0
```

#### `package.json`에서의 사용

```json
{
  "name": "my-project",
  "dependencies": {
    "chalk": "catalog:",
    "react": "catalog:react17",
    "react-dom": "catalog:react17"
  }
}
```

위 예시에서 `chalk`는 기본 카탈로그를 참조하고, `react`와 `react-dom`은 `react17`이라는 이름의 카탈로그를 참조합니다. `pnpm publish` 명령은 게시 전에 `catalog:` 인스턴스를 유효한 스펙으로 대체합니다.

### 2.3. 코딩 구현 및 모노레포 관리 영향 (Impact on Coding Implementation and Monorepo Management)

카탈로그 기능은 모노레포의 코딩 구현 및 관리에 다음과 같은 긍정적인 영향을 미칩니다.

* **상용구 코드 감소**: 각 하위 프로젝트의 `package.json`에서 반복되는 의존성 선언을 줄여줍니다.
* **쉬운 업그레이드**: 공통 의존성 버전을 한 곳에서만 업데이트하면 되므로, 대규모 업그레이드 프로세스가 훨씬 간소화됩니다.
* **병합 충돌 감소**: `pnpm-lock.yaml` 및 개별 `package.json` 파일에서 발생하는 의존성 버전 관련 병합 충돌 가능성을 크게 줄여, 팀 협업을 원활하게 합니다.
* **일관성 강화**: 워크스페이스 전반에 걸쳐 의존성 버전의 일관성을 강제하여, "내 컴퓨터에서만 되는" 문제를 줄이고 빌드 재현성을 높입니다.

### 2.4. 향후 `pnpm add` 및 `pnpm update` 명령과의 통합 (Future Integration with `pnpm add` and `pnpm update` Commands)

pnpm 9.5 출시 시점에는 `pnpm update` 명령이 아직 카탈로그를 지원하지 않습니다. `pnpm-workspace.yaml`에 정의된 의존성을 업데이트하려면 수동으로 새 버전 범위를 선택해야 합니다. 그러나 향후 릴리스에서는 `pnpm add` 명령이 구성된 기본 카탈로그에서 버전을 추가하고, `pnpm update` 명령이 카탈로그의 스펙 업데이트 여부를 사용자에게 묻는 기능이 추가될 예정입니다. 이는 카탈로그 기능이 초기 단계이지만, 모노레포 의존성 관리의 미래를 위한 강력한 기반을 제공하며 지속적으로 발전할 것임을 시사합니다.

-----

### Table 2: pnpm 9.5 카탈로그 기능 활용 예시 (Examples of pnpm 9.5 Catalogs Feature Usage)

| 시나리오 (Scenario)        | `pnpm-workspace.yaml` 예시                                   | `package.json` 예시                                         | 설명 (Description)                                                                                                    |
| :------------------------- | :----------------------------------------------------------- | :---------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |
| 기본 카탈로그 사용         | `yaml<br>catalog: { lodash: '^4.17.21' }<br>`             | `json<br>dependencies: { lodash: 'catalog:' }<br>`     | 워크스페이스의 모든 프로젝트가 lodash의 동일한 버전을 `catalog:` 키워드를 통해 참조.                                 |
| 명명된 카탈로그 사용       | `yaml<br>catalogs: { common-ui: { react: '^18.2.0', 'react-dom': '^18.2.0' } }<br>` | `json<br>dependencies: { react: 'catalog:common-ui', 'react-dom': 'catalog:common-ui' }<br>` | `common-ui`라는 이름의 카탈로그를 정의하여 `react` 및 `react-dom` 버전을 중앙에서 관리.                                |
| 다른 프로젝트에서 카탈로그 참조 | (동일한 `pnpm-workspace.yaml`)                               | `json<br>dependencies: { react: 'catalog:common-ui' }<br>` | 여러 프로젝트가 동일한 명명된 카탈로그를 참조하여 의존성 일관성을 유지.                                             |

-----

## 3\. 주요 버그 수정 및 개선사항 (Key Bug Fixes and Improvements)

2025년 상반기에는 pnpm v10의 주요 변경사항과 카탈로그 기능 도입 외에도, 안정성과 사용자 경험을 개선하기 위한 중요한 버그 수정 및 마이너 개선사항들이 있었습니다.

### `patchedDependencies` 적용 문제 해결 (Resolution of `patchedDependencies` Application Issue)

* **설명**: pnpm 10.6.0 버전(2025년 3월 6일 출시)에서 `patchedDependencies`가 올바르게 적용되지 않는 회귀 버그가 수정되었습니다. 이 문제는 pnpm 10.5.2에서 발생한 것으로 확인되었으며, `pnpm-lock.yaml` 파일에서 패치된 의존성에 대한 모든 참조가 제거되는 결과를 초래했습니다.

* **코딩 구현 영향**: `patchedDependencies`는 개발자가 의존성 패키지를 포크하지 않고도 사용자 정의 수정 사항을 적용할 수 있도록 하는 pnpm의 강력한 기능입니다. 이는 의존성의 버그를 수정하거나, 임시 기능을 추가하거나, 호환성 문제를 해결하는 데 매우 중요합니다. 이 기능이 적용되지 않는 회귀는 런타임 오류, 예상치 못한 동작, 심지어 보안 취약점으로 이어질 수 있습니다. 이 버그 수정은 패치된 의존성에 의존하는 프로젝트에 핵심적인 기능을 복원하고, 빌드 재현성과 안정성을 보장합니다. 개발자는 패치 관련 문제를 겪었다면 pnpm 10.6.0 이상으로 업데이트하는 것이 필수적입니다.

* **심층 분석**: 이 수정은 pnpm이 고급 사용 사례를 지원하고 주요 버전 업그레이드 중에도 사용자 안정성을 유지하려는 노력을 보여줍니다. `patchedDependencies`는 복잡한 프로젝트에서 필수적인 도구이며, 이 기능의 회복은 pnpm이 사용자 커뮤니티의 피드백에 신속하게 대응하고 있음을 나타냅니다. 이는 pnpm이 단순한 패키지 관리자를 넘어, 개발자가 복잡한 의존성 시나리오를 효과적으로 관리할 수 있도록 지원하는 도구로서의 역할을 강화합니다.

-----

## 4\. 개발자 워크플로우에 미치는 영향 및 권고사항 (Impact on Developer Workflow and Recommendations)

2025년 상반기 pnpm의 변경사항들은 개발자의 일상적인 워크플로우와 프로젝트 관리 방식에 상당한 영향을 미칩니다. 이러한 변화를 효과적으로 수용하기 위한 몇 가지 권고사항은 다음과 같습니다.

### 4.1. 마이그레이션 전략 및 고려사항 (Migration Strategies and Considerations)

* **철저한 테스트**: pnpm v10으로의 업그레이드는 여러 파괴적 변경사항을 포함하므로, 프로덕션 환경에 적용하기 전에 개발 및 CI/CD 환경에서 철저한 테스트를 수행해야 합니다. 특히 라이프사이클 스크립트의 기본 비활성화, `public-hoist-pattern` 변경, 그리고 `pnpm link` 동작 변화에 유의해야 합니다.
* **`package.json` 및 `pnpm-workspace.yaml` 업데이트**: `pnpm.onlyBuiltDependencies` 필드에 필요한 의존성을 명시하고, `public-hoist-pattern` 변경으로 인해 누락될 수 있는 패키지를 `devDependencies`에 추가하는 등 설정 파일을 검토하고 업데이트해야 합니다. 모노레포의 경우 `inject-workspace-packages` 설정과 카탈로그 정의를 고려해야 합니다.
* **CI/CD 파이프라인 조정**: 스크립트 환경 변수 감소 및 `NODE_ENV=production`에서의 모든 의존성 설치 변경은 CI/CD 스크립트의 수정이 필요할 수 있습니다. `pnpm self-update` 명령으로의 전환도 중요합니다.

### 4.2. 보안 및 성능 최적화 방안 (Security and Performance Optimization Measures)

* **기본 보안 활용**: 라이프사이클 스크립트의 기본 비활성화와 SHA256 해싱 강화는 프로젝트의 보안 태세를 크게 향상시킵니다. 개발자는 이를 적극적으로 활용하여 공급망 공격의 위험을 줄여야 합니다.
* **엄격한 의존성 관리**: pnpm의 **엄격한 의존성 해결 방식**은 "유령 의존성"을 방지하고 의존성 그래프를 명확하게 유지하는 데 도움이 됩니다. `public-hoist-pattern`의 변경은 이러한 엄격성을 더욱 강화하므로, 개발자는 명시적인 의존성 선언을 습관화해야 합니다.
* **성능 최적화 활용**: 글로벌 스토어 변경 및 더 빠른 반복 설치와 같은 내부 최적화는 전반적인 개발 및 빌드 시간을 단축시킵니다.

### 4.3. 모노레포 및 대규모 프로젝트 관리 팁 (Monorepo and Large-Scale Project Management Tips)

* **카탈로그 적극 활용**: pnpm 9.5의 카탈로그 기능은 모노레포에서 공통 의존성 버전을 중앙에서 관리하고 병합 충돌을 줄이는 데 매우 효과적입니다. 이를 통해 대규모 프로젝트의 유지보수성과 협업 효율성을 크게 높일 수 있습니다.
* **`inject-workspace-packages` 활용**: 특정 시나리오에서 `inject-workspace-packages` 설정을 통해 로컬 워크스페이스 의존성을 하드링크로 연결하는 것은 빌드 성능과 일관성을 개선하는 데 도움이 될 수 있습니다.
* **pnpm의 모노레포 강점 활용**: pnpm은 본질적으로 모노레포에 최적화된 패키지 관리자입니다. 변경사항들은 이러한 강점을 더욱 부각시키므로, 대규모 프로젝트에서는 pnpm의 기능을 최대한 활용하는 것이 권장됩니다.

### 4.4. 권장되는 개발 환경 설정 (Recommended Development Environment Setup)

* **Corepack을 통한 pnpm 버전 관리**: Node.js 16.13부터 제공되는 **Corepack**을 사용하여 프로젝트별 pnpm 버전을 관리하는 것이 좋습니다. 이는 팀 구성원 간의 개발 환경 일관성을 보장하는 데 도움이 됩니다.
* **IDE 통합 활용**: WebStorm과 같은 IDE는 pnpm과의 통합을 제공하여 패키지 설치, 업데이트, 스크립트 실행 등을 IDE 내에서 편리하게 수행할 수 있도록 지원합니다.

-----

## 결론 (Conclusion)

2025년 상반기 pnpm의 변경사항들은 패키지 관리의 **보안**, **성능**, 그리고 **대규모 프로젝트 관리 효율성**이라는 세 가지 핵심 영역에 걸쳐 상당한 발전을 이루었음을 보여줍니다. pnpm v10은 기본 보안을 강화하고 의존성 구조의 엄격성을 높이는 동시에, 내부 최적화를 통해 전반적인 성능을 개선했습니다. 특히, 의존성 라이프사이클 스크립트의 기본 비활성화와 `public-hoist-pattern`의 변경은 개발자에게 명시적인 설정과 의존성 관리에 대한 더 큰 책임을 요구하지만, 이는 장기적으로 더 견고하고 예측 가능한 빌드 환경을 조성하는 데 기여할 것입니다.

동시에 pnpm 9.5에서 도입된 카탈로그 기능은 모노레포 의존성 관리의 복잡성을 획기적으로 줄여줄 잠재력을 지니고 있으며, 이는 pnpm이 대규모 프로젝트를 위한 선도적인 솔루션으로서의 입지를 더욱 공고히 하는 중요한 단계입니다. `patchedDependencies` 버그 수정과 같은 안정성 개선 노력 또한 pnpm이 사용자 경험과 신뢰성을 중요하게 생각하고 있음을 보여줍니다.

이러한 변화들은 pnpm이 단순히 빠른 패키지 관리자를 넘어, 현대 소프트웨어 개발의 복잡한 요구사항, 특히 보안과 대규모 프로젝트 관리에 적극적으로 대응하며 진화하고 있음을 시사합니다. 개발자들은 이러한 핵심 변경사항들을 충분히 이해하고 적절한 마이그레이션 및 워크플로우 조정 전략을 수립함으로써, pnpm이 제공하는 향상된 이점을 최대한 활용할 수 있을 것입니다. pnpm은 앞으로도 Node.js 생태계에서 중요한 역할을 계속 수행하며, 개발자들에게 더욱 효율적이고 안전한 패키지 관리 경험을 제공할 것으로 기대됩니다.
