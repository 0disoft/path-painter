# 프로젝트 가이드라인

* 이 문서는 LLM이 프로젝트의 맥락을 정확히 이해하고, 더 효율적이며 프로젝트에 특화된 도움을 제공하도록 돕기 위해 작성돼 있습니다.

---

## 프로젝트 개요 및 목표

* **프로젝트 이름**: Path Painter
* **목표**: VS Code 탐색기 내 특정 폴더에 사용자가 직접 지정한 색상 배경을 적용해 시각적인 구분을 통해 개발 생산성을 향상하는 것을 목표로 합니다.
* **핵심 가치**: 직관적인 인터페이스, 시각적 명확성, 개인화된 작업 공간
* **디자인 톤 앤 매너**: 미니멀리즘, 모던하고 깔끔한
* **대상 사용자**: 복잡한 프로젝트 구조에서 작업하는 소프트웨어 개발자, 여러 프로젝트를 동시에 관리하는 프리랜서 개발자, 시각적 구분을 통해 작업 효율을 높이고 싶은 사용자.
* **주요 경쟁 서비스**: Folder Path Color (기존 VS Code 익스텐션)
* **비즈니스 모델**: 무료 오픈소스 익스텐션 (향후 프리미엄 기능 추가 고려 가능성 희박)
* **향후 확장 계획 (Roadmap)**:
  * **v1 (MVP)**:
    * 탐색기 컨텍스트 메뉴(우클릭 메뉴)에 "폴더 색상 설정" 항목 추가
    * 컨텍스트 메뉴에서 색상 선택 UI (예: VS Code 내장 Quick Pick 또는 Color Picker) 호출
    * 선택된 색상을 우클릭된 폴더 경로와 함께 `settings.json`에 저장
    * `settings.json`에 저장된 색상 정보를 기반으로 탐색기 폴더명에 배경색 적용
    * 폴더 색상 제거 기능 (컨텍스트 메뉴를 통해)
  * **v2 (향후)**:
    * 특정 폴더 패턴(예: `src/components/**`)에 대한 색상 자동 지정 기능
    * VS Code 테마와의 색상 조화 자동 조정 기능
    * 색상 테마 프리셋 제공
    * Git 상태(수정/추가 등)에 따른 색상 오버레이 옵션 제공
* **프로젝트 깃헙 레포지토리**: `https://github.com/0disoft/path-painter`

---

## 기술 스택 및 설정 전략

* **개발 유형**: 데스크톱 애플리케이션 (VS Code 익스텐션)
* **프론트엔드/풀스택 프레임워크**: 필요 없음 (웹뷰 기능 추가 시 고려 가능)
  * **핵심 기능 라이브러리/서비스**:
    * VS Code Extension API: 익스텐션의 모든 UI 및 로직 처리에 필수적입니다.
* **스타일링 툴**: 바닐라 CSS
* **백엔드**: 필요 없음 (서버리스 함수, 헤드리스 CMS, 별도의 백엔드 서버 모두 필요 없음)
* **런타임 환경 및 패키지 매니저**: Node.js (pnpm)
* **데이터베이스**: 필요 없음 (VS Code `settings.json`을 데이터 저장소로 활용)
  * **ORM/데이터베이스 클라이언트**: 해당 없음
* **배포 전략 및 플랫폼**: VS Code Marketplace
  * **CI/CD 파이프라인**: GitHub Actions (익스텐션 패키징 및 Marketplace 발행 자동화)
* **지역화 (l10n) 전략**: 수동 준비 (LLM을 이용한 직접 번역 포함), 기본 언어: 영어 (VS Code 자체 지역화 메커니즘 활용)
  * **관련 라이브러리/서비스**: VS Code Localization API (vscode-nls)
* **API 클라이언트 (테스트 및 문서화)**: 해당 없음 (외부 API 통신 없음)
* **데이터 유효성 검사**: Zod (사용자 설정 유효성 검사 시 고려)
* **프로젝트 초기화 도구**: `create-vs-code-extension` (VS Code 익스텐션 프로젝트 생성에 최적화된 도구)

---

## 개발 환경

* **OS**: 윈도우 11
* **IDE**: VS Code
* **터미널**: Git Bash
* **쉘 프롬프트 커스터마이저**: Starship

---

## 구현해야 할 페이지와 기능

* **핵심 페이지**:
  * VS Code 탐색기 (기존 VS Code UI에 기능 통합)
  * VS Code 설정 페이지 (settings.json을 통한 고급 설정 확인)
* **주요 기능 (MVP)**:
  * 탐색기 컨텍스트 메뉴(우클릭 메뉴)에 "폴더 색상 설정" 항목 추가
  * 컨텍스트 메뉴에서 색상 선택 UI (예: VS Code 내장 Quick Pick 또는 Color Picker) 호출
  * 선택된 색상을 우클릭된 폴더 경로와 함께 `settings.json`에 저장
  * `settings.json`에 저장된 색상 정보를 기반으로 탐색기 폴더명에 배경색 적용
  * 폴더 색상 제거 기능 (컨텍스트 메뉴를 통해)
* **추가 고려 기능 (선택 사항)**:
  * 기존 색상이 적용된 폴더에 대한 시각적 표시 (예: 컨텍스트 메뉴에 현재 색상 미리보기)
  * 색상 코드 직접 입력 기능 (HEX, RGB 등)
  * `settings.json`에서 직접 수정하지 않고도, 익스텐션 자체 설정 UI를 통해 적용된 폴더 색상 목록을 보여주고 관리(수정/삭제)하는 기능

---

## 코딩 규칙 및 스타일

* **변수/함수명**: 명확하고 의미를 쉽게 유추할 수 있는 이름을 사용합니다 (예: `getData` 대신 `fetchUserProfileData`).
* **코드 라인 길이**: 한 줄의 최대 길이는 80자 (띄어쓰기 포함)를 지킵니다 (예외: 긴 URL, 코드 블록, 테이블, 제목).
* **함수 길이**: 함수의 최대 길이는 50라인 (주석 및 줄바꿈 포함)을 지킵니다.
* **들여쓰기**: 특별한 경우가 아니라면 2칸 공백을 사용합니다.
* **커밋 메시지**: Gitmoji 형식을 사용한 영어 코멘트를 작성합니다.
* **Single Source of Truth**: 서비스 이름, API 엔드포인트, 주요 설정 값 등은 코드 곳곳에 하드코딩하지 않습니다. 모든 설정은 별도의 설정 파일이나 상수 모듈에 모아서, 딱 한 군데만 수정하면 전체에 적용되도록 만듭니다.
* **모듈성**: 코드를 작고 응집도 높은 모듈로 분리하여 재사용성과 유지보수성을 높입니다.
* **가독성**: 다른 개발자가 코드를 쉽게 이해할 수 있도록 작성합니다.
* **성능**: 특히 고빈도 호출이 예상되는 API나 데이터 처리 로직에서는 성능을 최우선으로 고려합니다.
* **보안**: 사용자 데이터 보호, 인증/인가, 입력 유효성 검사 등 보안을 항상 염두에 둡니다 (프로젝트 특성에 따른 추가 보안 고려사항 명시 가능: 예: XSS/CSRF 방지, SQL Injection 방지, 비밀번호 해싱).
* **데이터 정확성**: 제공되는 데이터(특히 계산 결과)는 최신 법규와 공식 데이터를 기반으로 최대한의 정확성을 보장해야 합니다. 부동 소수점 오류 방지를 위한 정밀한 숫자 연산 라이브러리 사용을 권장합니다.
* **에러 처리**: 모든 잠재적인 에러 상황에 대해 견고하고 명확한 에러 처리 로직을 구현합니다 (예: 서버 측 폼 액션에서 `fail` 함수를 사용하여 개발자에게 구체적인 오류 메시지 전달).
* **접근성 (A11y)**: 웹 애플리케이션 개발 시 웹 접근성 표준을 준수하여 모든 사용자가 쉽게 접근하고 이용할 수 있도록 합니다 (처음부터 강력한 접근성 보장).
* **주석 작성 규칙**: 주석은 '왜' 이 코드가 존재하는지, 코드를 변경했다면 '왜' 변경했는지, 특정 비즈니스 논리나 기술적 절충안 등 코드만으로 설명하기 어려운 배경 정보를 제공하는 데 사용합니다.
* **마크다운 작성 규칙**: 다음은 자주 발생하는 마크다운 오류이므로 항상 유의하여 작성합니다.
  * `MD030/list-marker-space`: 리스트 마커 다음에는 정확히 한 칸의 공백을 사용합니다.
  * `MD022/blanks-around-headings`: 제목(Heading)의 위와 아래에는 항상 한 줄씩 비워둡니다.
  * `MD047/single-trailing-newline`: 파일의 마지막은 항상 하나의 개행 문자로 끝나야 합니다.
  * `MD024/no-duplicate-heading`: 한 문서 내에서 동일한 내용의 제목을 중복으로 사용하지 않습니다.
  * `MD007/ul-indent`: 중첩되지 않은 리스트는 2칸 들여쓰기를 사용합니다.

---

## AI 지식 베이스 및 문서화

LLM의 학습 데이터 한계(Knowledge Cutoff)를 극복하고, 프로젝트의 기술적 맥락과 최신 정보를 정확하게 파악하기 위해 이 중앙화된 지식 베이스를 관리합니다. 코드를 분석하거나 생성할 때, 항상 이 내부 지식 베이스의 문서를 가장 먼저 확인합니다.

* **위치**: LLM과 관련된 모든 문서는 `/.gemini/` 폴더 아래에 중앙화하여 관리합니다.

### 프레임워크 최신 정보 (`/.gemini/.changelogs/` 및 `/.gemini/.context7/`)

* **목적**: LLM의 지식 격차를 해소하고, 최신 프레임워크 정보를 효과적으로 활용하기 위해 두 가지 유형의 문서를 관리합니다.
  * `/.gemini/.changelogs/`: 주요 프레임워크의 분기별(예: 25년 상반기, 하반기) 최신 업데이트 중, 반드시 알아야 할 핵심 변경 사항이나 주요 기능 추가 내용을 요약하여 저장합니다.
  * `/.gemini/.context7/`: `Context7` MCP를 통해 방대한 공식 문서를 검색하기 전, 로컬에서 자주 사용하는 기능의 일반적인 사용법이나 코드 스니펫을 빠르게 확인하기 위한 용도로 사용됩니다.
* **LLM 활용 가이드**:
  * 프레임워크의 최신 버전과 관련된 작업을 수행할 때는 먼저 `/.gemini/.changelogs/` 폴더를 확인하여 중요한 변경 사항(breaking changes 등)을 코드에 반영합니다.
  * 특정 기능의 기본적인 사용법이나 예제가 필요할 때는 `/.gemini/.context7/` 폴더의 문서를 우선적으로 참조하여 빠르게 정보를 얻고, 더 상세한 내용이 필요할 경우에 `Context7` MCP를 활용합니다.

---

## LLM과의 협업

* LLM이 문제 해결을 완료하고 사용자로부터 긍정적인 응답을 받으면, `.gemini/.commitmsg.txt` 파일에 Gitmoji 형식의 영어 커밋 메시지를 작성합니다.
* LLM이 작업을 완료하고 사용자로부터 긍정적인 응답을 받으면, `.gemini/tasks/` 폴더에 상세 작업 기록을 Markdown 파일로 작성합니다. 상세 형식은 `.gemini/tasks/task_record_example.md` 파일을 참조합니다.
* LLM의 답변(응답)은 한국어로 합니다.
* 폴더명과 파일명은 영어로 작성해야 합니다.
* 변수명, 클래스명 등은 영어로 작성해야 합니다.
* 코드 주석은 영어로 작성합니다.
* 오류 로그는 영어로 작성합니다.
* 홈페이지에 표시되는 메시지나 서비스를 이용하게 될 사용자와의 상호작용 메시지는 페이지의 기본 언어 설정 및 다국어 지원 여부에 따라 적절한 언어(예: 영어 또는 한국어)로 작성합니다.
